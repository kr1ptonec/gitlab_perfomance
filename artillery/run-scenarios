#!/usr/bin/env ruby
# rubocop:disable Style/GlobalVars

require 'json'
require 'yaml'
require 'tempfile'
require 'open-uri'
require 'open3'
require 'shellwords'
require 'table_print'

$current_time = Time.now.strftime("%Y%m%d_%H%M%S")
$env_name = nil

class ::Hash
  def deep_merge(second)
    merger = proc do |key, v1, v2|
      Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2
    end

    merge(second, &merger)
  end
end

def usage!
  warn(
    <<-DOC
    Usage: #{$PROGRAM_NAME} [environment-script] -- [scenario-script(s)]

    Runs the specified scenario(s) against the given environment. Requires the specified scenario(s) and environment files to exist.

    Optional Environment Variables:
      ARTILLERY_VERBOSE - Shows all output from Artillery. Warning: This output is very verbose. Default: false.
      QUARANTINED - Will include any tests inside the artillery/scenarios/quarantined folder when true. Default: false.

    Example(s):
      #{$PROGRAM_NAME} artillery/environments/onprem.testbed.gitlab.net.yaml -- artillery/scenarios/api_v4_projects_merge_requests.yml
    DOC
  )
  exit 1
end

def output_path
  ENV["OUTPUT_PATH"] || File.join("out", "#{$env_name}_#{$current_time}")
end

def file_output_path(files, suffix)
  base_names = files.map do |file|
    File.basename(file, File.extname(file))
  end
  base_name = base_names.join("_")

  File.join(output_path, base_name + suffix)
end

def run_artillery_command(cmd_name, *args)
  cmd = [
    'node_modules/.bin/artillery',
    cmd_name
  ] + args

  stdout_stderr_str, status = Open3.capture2e(*cmd)
  # Filter and print output to reduce significant noise with Artillery Expect plugin
  stdout_stderr_str.gsub!(%r{\*\s[A-Z]+\s[a-zA-Z0-9\-%\/_.]+\s\R[a-zA-Z\s]+200\s\R}, '') unless ENV['ARTILLERY_VERBOSE']
  puts stdout_stderr_str

  status.success?
end

def run(run_name, final_config)
  final_config_path = file_output_path(run_name, "_config.yaml")
  result_json_file = file_output_path(run_name, "_result.json")
  result_html_file = file_output_path(run_name, "_result.html")

  File.write(final_config_path, final_config.to_yaml)

  warn(">> Running #{final_config_path}...")
  warn(final_config.to_yaml)
  warn

  warn(">> Running Artillery...")
  run_success = run_artillery_command('run', final_config_path, '-o', result_json_file)
  run_artillery_command('report', result_json_file, '-o', result_html_file)
  warn

  warn(">> Parsing results #{result_json_file}...")
  run_result = JSON.parse(File.read(result_json_file))
  warn

  final_result = {
    Result: run_success ? "Yes" : "No",
    P95: run_result.dig("aggregate", "latency", "p95"),
    RPS_Count: run_result.dig("aggregate", "rps", "count"),
    RPS_Mean: run_result.dig("aggregate", "rps", "mean")
  }

  [run_success, final_result]
end

base_config = {}
run_name = []

while file = ARGV.shift
  break if file == '--'

  config = YAML.load_file(file)
  base_config = base_config.deep_merge(config)
  run_name << file
  $env_name = File.basename(file, '.yml') if File.dirname(file).include?('artillery/environments')
end

usage! unless ARGV.any?
raise "Artillery has not been installed. Run 'npm install' on the project root to install." unless File.exist?('node_modules/.bin/artillery')

warn(">> Saving all results to #{output_path}.")
FileUtils.mkdir_p(output_path)

aggregated_results = []
aggregated_results_path = file_output_path(run_name, "_aggregated_results.json")

aggregated_success = true

ARGV.each do |file|
  config = YAML.load_file(file)
  file_name = File.basename(file)
  file_run_name = run_name + [file]

  success, result = run(file_run_name, config.deep_merge(base_config))

  aggregated_results << { Name: file_name }.merge(result)
  aggregated_success &&= success
rescue Interrupt
  warn
  warn("Caught the interrupt. Stopping.")
  warn
  aggregated_success = false
  break
rescue StandardError => e
  warn("Test failed: #{e.message}.")
  aggregated_success = false
end

warn(">> Aggregated results: #{aggregated_results_path}")
File.write(file_output_path(run_name, "_aggregated_results.json"), aggregated_results.to_json)

tp.set(:max_width, 100)
tp(aggregated_results)
File.open(file_output_path(run_name, "_aggregated_results.txt"), 'w') do |file|
  tp.set :io, file
  tp(aggregated_results)
  tp.clear :io
end

unless aggregated_success
  warn(">> Some scenarios failed.")
  exit(1)
end
