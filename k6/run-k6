#!/usr/bin/env ruby

require 'chronic_duration'
require 'down/http'
require 'fileutils'
require 'http'
require 'json'
require 'open3'
require 'optimist'
require 'os'
require 'rainbow'
require 'table_print'
require 'time'
require 'tmpdir'

dir_name = File.dirname($PROGRAM_NAME)

opts = Optimist.options do
  banner "Usage: run-k6 [options]"
  banner "\nRuns k6 Test(s) with the given Scenario against the specified Environment."
  banner "\nOptions:"
  opt :environment, "Environment Config file path that contains the relevant Environment Variables to be passed to the tests.", type: :string, required: true
  opt :scenario, "Path of Scenario Config file path that the tests should be run with.", type: :string, default: "#{dir_name}/scenarios/20s_2rps.json"
  opt :tests, "Path of Test file or folder paths to run.", type: :strings, default: ["#{dir_name}/tests"]
  opt :standalone, "Include any tests inside the #{dir_name}/tests/standalone folder when true.", type: :flag, default: false
  opt :quarantined, "Include any tests inside the #{dir_name}/tests/quarantined folder when true.", type: :flag, default: false
  opt :upload_results, "Upload test results to a InfluxDB server. Requires INFLUXDB_URL Environment Variable to be set.", type: :flag, default: false
  opt :help, 'Show this help message'
  banner "\nEnvironment Variables:"
  banner "  ACCESS_TOKEN             A valid GitLab Personal Access Token for the specified environment that's required by various tests. The token should come from a User that has admin access for the project(s) to be tested and have API and read_repository permissions. (Default: nil)"
  banner "  INFLUXDB_URL             URL for a InfluxDB server that k6 will upload results to (creates database named k6db). (Default: nil)"
  banner "\nExamples:"
  banner "  Running all Tests with the 60s_200rps Scenario against the 10k Environment:"
  banner "    #{$PROGRAM_NAME} --environment #{dir_name}/environments/10k.json --scenario #{dir_name}/scenarios/60s_200rps.json"
  banner "  Run a specific Test with the 20s_2rps Scenario against the onprem Environment:"
  banner "    #{$PROGRAM_NAME} --environment #{dir_name}/environments/onprem.json --scenario #{dir_name}/scenarios/20s_2rps.json --tests #{dir_name}/tests/api_v4_projects.js"
end

def setup_k6
  k6_version = ENV['K6_VERSION'] || '0.25.1'

  ['k6', File.join(Dir.tmpdir, 'k6')].each do |k6|
    return k6 if Open3.capture2e("#{k6} version" + ';')[0].strip == "k6 v#{k6_version}"
  end

  if OS.linux?
    k6_url = ENV['K6_URL'] || "https://github.com/loadimpact/k6/releases/download/v#{k6_version}/k6-v#{k6_version}-linux#{OS.bits}.tar.gz"
    warn Rainbow("k6 not found or different version detected. Downloading k6 v#{k6_version} from #{k6_url} to system temp folder...").yellow

    k6_archive = Down::Http.download(k6_url)
    extract_output, extract_status = Open3.capture2e('tar', '-xzvf', k6_archive.path, '-C', File.dirname(k6_archive.path), '--strip-components', '1')
    raise "k6 archive extract failed:\b#{extract_output}" unless extract_status
  elsif OS.mac?
    k6_url = ENV['K6_URL'] || "https://github.com/loadimpact/k6/releases/download/v#{k6_version}/k6-v#{k6_version}-mac.zip"
    warn Rainbow("k6 not found or wrong version detected. Downloading k6 version #{k6_version} from #{k6_url} to system temp folder...").yellow

    k6_archive = Down::Http.download(k6_url)
    extract_output, extract_status = Open3.capture2e('unzip', '-j', k6_archive.path, '-d', File.dirname(k6_archive.path))
    raise "k6 archive extract failed:\b#{extract_output}" unless extract_status
  elsif OS.windows?
    raise "k6 not found or wrong version detected. Please install k6 version #{k6_version} on your machine and ensure it's found on the PATH"
  end

  File.join(File.dirname(k6_archive.path), 'k6')
end

def setup_env_vars(env_file:, scenario_file:)
  required_vars = %w[ENVIRONMENT_NAME ENVIRONMENT_URL PROJECT_GROUP PROJECT_NAME PROJECT_COMMIT_SHA PROJECT_BRANCH
                     PROJECT_FILE_PATH PROJECT_MR_COMMITS_IID PROJECT_MR_DISCUSSIONS_IID PROJECT_SIGNED_COMMIT_SHA]
  env_file_vars = JSON.parse(File.read(env_file))
  required_vars.each do |var_name|
    raise "Required environment variable #{var_name} has not been set via config file or globally. Exiting..." unless ENV[var_name] || env_file_vars[var_name]
  end

  env_vars = {}
  env_file_vars.each do |var_name, var_value|
    env_vars[var_name] = ENV[var_name].dup || var_value
  end

  env_vars['ENVIRONMENT_URL'].chomp!('/')

  scenario_file_vars = JSON.parse(File.read(scenario_file))
  env_vars['SCENARIO_RPS'] = scenario_file_vars['rps'].to_s
  env_vars['SCENARIO_STAGES'] = scenario_file_vars['stages'].to_json
  env_vars['RPS_COUNT_TARGET'] ||= begin
    duration = scenario_file_vars['stages'].inject(0.0) { |sum, n| sum + n['duration'].delete('a-z').to_f }
    (duration * scenario_file_vars['rps'].to_f).to_i.to_s
  end
  env_vars['RPS_MEAN_TARGET'] ||= scenario_file_vars['rps'].to_f.to_s

  env_vars['SUCCESS_RATE_THRESHOLD'] ||= '0.95'
  env_vars['GIT_ENDPOINT_THRESHOLD'] ||= '0.1'

  env_vars
end

def get_env_version(env_vars:)
  res = HTTP.headers('PRIVATE-TOKEN': ENV['ACCESS_TOKEN']).get("#{env_vars['ENVIRONMENT_URL']}/api/v4/version")
  version = JSON.parse(res.body.to_s).values.join(' ')
  version == '401 Unauthorized' ? nil : version
end

def get_tests(test_paths:, quarantined:, standalone:)
  tests = []
  test_paths.each do |test|
    if File.directory?(test)
      tests += Dir.glob("#{test}/*.js")
      tests += Dir.glob("#{test}/quarantined/*.js") if quarantined
      tests += Dir.glob("#{test}/standalone/*.js") if standalone
    elsif File.file?(test)
      tests << test
    end
  end
  raise "\nNo tests found in specified path(s):\n#{test_paths.join("\n")}\nExiting..." if tests.empty?

  tests.uniq.sort_by { |path| File.basename(path, '.js') }
end

def run_k6(k6_path:, env_vars:, scenario_file:, test_file:, upload_results: false)
  test_name = File.basename(test_file, '.js')
  puts "Running k6 test '#{test_name}' against environment '#{env_vars['ENVIRONMENT_NAME']}'..."

  cmd = [k6_path, 'run']
  cmd += ['--config', scenario_file] if scenario_file
  cmd += ['--out', "influxdb=#{ENV['INFLUXDB_URL']}/k6db"] if upload_results && ENV['INFLUXDB_URL'] && HTTP.get("#{ENV['INFLUXDB_URL']}/ping").status.success?
  cmd += ['--tag', "environment=#{env_vars['ENVIRONMENT_NAME']}"]
  cmd += ['--summary-time-unit', 'ms']
  cmd += [test_file]

  status = nil
  output = []
  Open3.popen2e(env_vars, *cmd) do |stdin, stdout_stderr, wait_thr|
    stdin.close
    stdout_stderr.each do |line|
      raise ArgumentError, "Test '#{test_name}' requires environment variable ACCESS_TOKEN to be set. Skipping...\n" if line =~ /(GoError:).*(ACCESS_TOKEN)/
      raise "No requests completed in time by the end of the test. This is likely due to no responses being received from the server." if line =~ /No data generated/

      output << line.lstrip
      puts line
    end
    status = wait_thr.value
  end

  [status.success?, output]
end

def parse_k6_results(output:)
  results = []
  matches = {}

  output.each do |line|
    case line
    when /Test finished/
      matches[:duration] = line.match(/(t=)(.*s)/)
    when /http_req_duration/
      matches[:p95] = line.match(/(p\(95\)=)(\d+\.\d+)([a-z]+)/)
    when /RPS Threshold/
      matches[:rps_threshold] = line.match(/\d+\.\d+\/s/)
    when /http_reqs/
      matches[:rps] = line.match(/(\d+\.\d+)(\/s)/)
    when /Success Rate Threshold/
      matches[:success_rate_threshold] = line.match(/\d+(\.\d+)?\%/)
    when /successful_requests/
      matches[:success_rate] = line.match(/\d+(\.\d+)?\%/)
    end
  end

  results.insert(0, [:Duration, ChronicDuration.parse(matches[:duration][2]).round(2).to_s + 's'])
  results.insert(1, [:P95, matches[:p95][2] + matches[:p95][3]])
  results.insert(2, [:RPS, "#{matches[:rps][1].to_f.round(2)}#{matches[:rps][2]} (>#{matches[:rps_threshold][0]})"])
  results.insert(3, [:'Success Rate', "#{matches[:success_rate][0]} (>#{matches[:success_rate_threshold][0]})"])

  results.compact.to_h
end

puts Rainbow("GitLab Performance Toolkit - k6 load test runner").color(230, 83, 40)
warn Rainbow("\nEnvironment Variable ACCESS_TOKEN has not been set. Various tests require this for authentication and they will be skipped for this run. See command help for more info...").yellow unless ENV['ACCESS_TOKEN']

k6_path = setup_k6

# Variables
env_vars = setup_env_vars(env_file: opts[:environment], scenario_file: opts[:scenario])
env_version = get_env_version(env_vars: env_vars)
start_time = Time.now

results_dir = File.join("#{dir_name}/results", "#{env_vars['ENVIRONMENT_NAME']}_#{start_time.strftime('%Y%m%d_%H%M%S')}")
puts "\nSaving all test results to #{results_dir}"
FileUtils.mkdir_p(results_dir)

aggregated_results = []
aggregated_success = true

# Collect and run tests
tests = get_tests(test_paths: opts[:tests], quarantined: opts[:quarantined], standalone: opts[:standalone])
tests.each do |test_file|
  test_name = File.basename(test_file, '.js')

  success, output = run_k6(k6_path: k6_path, env_vars: env_vars, scenario_file: opts[:scenario], test_file: test_file, upload_results: opts[:upload_results])

  parsed_results = parse_k6_results(output: output)
  success = false if parsed_results.nil?
  aggregated_results << { Name: test_name }.merge(parsed_results).merge({ Result: success ? "Passed" : "Failed" })
  aggregated_success &&= success
rescue Interrupt
  warn Rainbow("Caught the interrupt. Stopping.").yellow
  exit
rescue ArgumentError => e
  warn Rainbow(e.message).yellow
  next
rescue StandardError => e
  warn Rainbow("Test failed: #{e.message}.").red
  aggregated_success = false
end

# Save test times
end_time = Time.now
run_time = (end_time - start_time).round(2)
test_epoch_times_txt = File.join(results_dir, "#{env_vars['ENVIRONMENT_NAME']}_test_epoch_times.txt")
File.open(test_epoch_times_txt, 'w') do |file|
  file.write("START_TIME=#{(start_time.to_f * 1000).to_i}\n")
  file.write("END_TIME=#{(end_time.to_f * 1000).to_i}\n")
  file.write("RUN_TIME=#{run_time}")
end

puts Rainbow("\nAll k6 tests have finished after #{run_time}s!").green

# Parse results
if aggregated_results.empty?
  puts "No tests reported any results. Exiting..."
  exit
end

aggregated_results_json = File.join(results_dir, "#{env_vars['ENVIRONMENT_NAME']}_aggregated_results.json")
aggregated_results_txt = File.join(results_dir, "#{env_vars['ENVIRONMENT_NAME']}_aggregated_results.txt")

test_details_summary = <<~DOC
  Environment:    #{env_vars['ENVIRONMENT_NAME']} #{env_version ? "(#{env_version})" : ''}
  Scenario:       #{File.basename(opts[:scenario], '.json')}
  Date:           #{start_time.strftime('%F')}
  Run Time:       #{run_time}s (Start: #{start_time.utc.strftime('%T %Z')}, End: #{end_time.utc.strftime('%T %Z')})
DOC
puts "\nResults summary:\n\n#{test_details_summary}\n"
tp.set(:max_width, 100)
tp(aggregated_results)

puts "\nSaving results summary to:\n#{aggregated_results_json}\n#{aggregated_results_txt}"
File.write(aggregated_results_json, aggregated_results.to_json)
File.open(aggregated_results_txt, 'w') do |file|
  file.write("```\n")
  file.write("#{test_details_summary}\n")
  tp.set :io, file
  tp(aggregated_results)
  tp.clear :io
  file.write("```\n")
end

unless aggregated_success
  puts Rainbow("\nOne or more k6 tests have failed...").red
  exit(1)
end
